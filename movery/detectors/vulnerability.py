import json
import re
from typing import List, Optional
from dataclasses import dataclass
import ast
import astroid
from abc import ABC

@dataclass
class Signature:
    """漏洞签名类"""
    id: str
    name: str
    severity: str
    code_patterns: List[str]

@dataclass
class VulnerabilityMatch:
    """漏洞匹配结果类"""
    signature: Signature
    line_number: int
    matched_code: str
    confidence: float

class VulnerabilityDetector:
    """漏洞检测器类"""
    
    def __init__(self):
        """初始化漏洞检测器"""
        self.signatures: List[Signature] = []
        self.min_confidence = 0.7

    def load_signatures(self, signature_file: str) -> None:
        """从JSON文件加载漏洞签名

        Args:
            signature_file: 签名文件路径
        """
        with open(signature_file, 'r') as f:
            data = json.load(f)
            self.signatures = [
                Signature(
                    id=sig['id'],
                    name=sig['name'],
                    severity=sig['severity'],
                    code_patterns=sig['code_patterns']
                )
                for sig in data['signatures']
            ]

    def detect_file(self, file_path: str) -> List[VulnerabilityMatch]:
        """检测文件中的漏洞

        Args:
            file_path: 待检测的文件路径

        Returns:
            List[VulnerabilityMatch]: 漏洞匹配结果列表
        """
        with open(file_path, 'r') as f:
            content = f.read()
            
        matches = []
        for signature in self.signatures:
            for pattern in signature.code_patterns:
                # 使用正则表达式查找匹配
                for match in re.finditer(pattern, content):
                    line_number = content.count('\n', 0, match.start()) + 1
                    matched_code = match.group()
                    confidence = self._calculate_confidence(matched_code, pattern)
                    
                    if confidence >= self.min_confidence:
                        matches.append(VulnerabilityMatch(
                            signature=signature,
                            line_number=line_number,
                            matched_code=matched_code,
                            confidence=confidence
                        ))

        return matches

    def _calculate_confidence(self, matched_code: str, pattern: str) -> float:
        """计算匹配的置信度

        Args:
            matched_code: 匹配到的代码
            pattern: 匹配模式

        Returns:
            float: 置信度(0-1)
        """
        # 基本匹配的置信度为0.8
        confidence = 0.8
        
        # 根据匹配的完整性增加置信度
        if len(matched_code) > 10:
            confidence += 0.05
            
        # 根据上下文增加置信度
        if 'import' in matched_code:
            confidence += 0.05
            
        # 根据模式的特异性增加置信度
        if len(pattern) > 20:
            confidence += 0.05
            
        # 根据函数调用的参数增加置信度
        if '(' in matched_code and ')' in matched_code:
            confidence += 0.05
            
        return round(min(confidence, 1.0), 2)

    def analyze_ast(self, node: ast.AST) -> List[VulnerabilityMatch]:
        """分析AST节点中的漏洞

        Args:
            node: AST节点

        Returns:
            List[VulnerabilityMatch]: 漏洞匹配结果列表
        """
        matches = []
        
        # 遍历AST节点
        for child in ast.walk(node):
            # 检查函数调用
            if isinstance(child, ast.Call):
                func = child.func
                func_name = None
                
                if isinstance(func, ast.Name):
                    func_name = func.id
                elif isinstance(func, ast.Attribute):
                    try:
                        parts = []
                        current = func
                        while isinstance(current, ast.Attribute):
                            parts.append(current.attr)
                            current = current.value
                        if isinstance(current, ast.Name):
                            parts.append(current.id)
                            func_name = ".".join(reversed(parts))
                    except AttributeError:
                        continue
                
                if func_name is None:
                    continue
                    
                # 获取函数调用的参数
                args_str = ""
                for arg in child.args:
                    if isinstance(arg, ast.Constant):
                        args_str += str(arg.value)
                    elif isinstance(arg, ast.Name):
                        args_str += arg.id
                    elif isinstance(arg, ast.List):
                        args_str += "[...]"
                    elif isinstance(arg, ast.Dict):
                        args_str += "{...}"
                
                # 构建完整的函数调用字符串
                full_call = f"{func_name}({args_str})"
                    
                # 检查是否匹配任何签名
                for signature in self.signatures:
                    for pattern in signature.code_patterns:
                        try:
                            if re.search(pattern, full_call, re.IGNORECASE):
                                confidence = self._calculate_confidence(full_call, pattern)
                                if confidence >= self.min_confidence:
                                    matches.append(VulnerabilityMatch(
                                        signature=signature,
                                        line_number=child.lineno,
                                        matched_code=full_call,
                                        confidence=confidence
                                    ))
                        except re.error:
                            continue
                            
        return matches

    def detect_similar_patterns(self, code: str, threshold: float = 0.7) -> List[VulnerabilityMatch]:
        """检测相似的漏洞模式

        Args:
            code: 待检测的代码
            threshold: 相似度阈值

        Returns:
            List[VulnerabilityMatch]: 漏洞匹配结果列表
        """
        matches = []
        
        # 使用astroid进行更深入的代码分析
        try:
            module = astroid.parse(code)
            for node in module.nodes_of_class(astroid.Call):
                # 获取调用的函数名和参数
                func_name = None
                args_str = ""
                
                try:
                    if isinstance(node.func, astroid.Name):
                        func_name = node.func.name
                    elif isinstance(node.func, astroid.Attribute):
                        parts = []
                        current = node.func
                        while isinstance(current, astroid.Attribute):
                            parts.append(current.attrname)
                            current = current.expr
                        if isinstance(current, astroid.Name):
                            parts.append(current.name)
                            func_name = ".".join(reversed(parts))
                            
                    # 获取参数
                    for arg in node.args:
                        if isinstance(arg, astroid.Const):
                            args_str += str(arg.value)
                        elif isinstance(arg, astroid.Name):
                            args_str += arg.name
                        else:
                            args_str += "..."
                        args_str += ", "
                    args_str = args_str.rstrip(", ")
                        
                except (AttributeError, astroid.AstroidError):
                    continue
                
                if func_name is None:
                    continue
                    
                # 构建完整的函数调用字符串
                full_call = f"{func_name}({args_str})"
                    
                # 检查每个签名
                for signature in self.signatures:
                    for pattern in signature.code_patterns:
                        try:
                            # 首先尝试正则表达式匹配
                            if re.search(pattern, full_call, re.IGNORECASE):
                                confidence = self._calculate_confidence(full_call, pattern)
                                matches.append(VulnerabilityMatch(
                                    signature=signature,
                                    line_number=node.lineno,
                                    matched_code=full_call,
                                    confidence=confidence
                                ))
                            else:
                                # 如果正则表达式不匹配，尝试计算相似度
                                similarity = self._calculate_similarity(full_call, pattern)
                                if similarity >= threshold:
                                    matches.append(VulnerabilityMatch(
                                        signature=signature,
                                        line_number=node.lineno,
                                        matched_code=full_call,
                                        confidence=similarity
                                    ))
                        except (re.error, Exception):
                            continue
                            
        except astroid.AstroidError:
            pass  # 忽略解析错误
            
        return matches

    def _calculate_similarity(self, str1: str, str2: str) -> float:
        """计算两个字符串的相似度

        Args:
            str1: 第一个字符串
            str2: 第二个字符串

        Returns:
            float: 相似度(0-1)
        """
        # 使用最长公共子序列(LCS)计算相似度
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                    
        lcs_length = dp[m][n]
        return lcs_length / max(m, n)  # 归一化的相似度
