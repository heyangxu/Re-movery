package detectors

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"regexp"
	"strings"
	"sync"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
)

// Signature 表示漏洞签名
type Signature struct {
	ID           string   `json:"id"`
	Name         string   `json:"name"`
	Severity     string   `json:"severity"`
	CodePatterns []string `json:"code_patterns"`
}

// Match 表示漏洞匹配结果
type Match struct {
	Signature   Signature
	LineNumber  int
	MatchedCode string
	Confidence  float64
}

// VulnerabilityDetector 漏洞检测器
type VulnerabilityDetector struct {
	signatures    []Signature
	minConfidence float64
	mu           sync.RWMutex
}

// NewVulnerabilityDetector 创建新的漏洞检测器
func NewVulnerabilityDetector() *VulnerabilityDetector {
	return &VulnerabilityDetector{
		minConfidence: 0.7,
	}
}

// LoadSignatures 从JSON文件加载漏洞签名
func (d *VulnerabilityDetector) LoadSignatures(signatureFile string) error {
	data, err := ioutil.ReadFile(signatureFile)
	if err != nil {
		return fmt.Errorf("读取签名文件失败: %v", err)
	}

	var sigData struct {
		Signatures []Signature `json:"signatures"`
	}

	if err := json.Unmarshal(data, &sigData); err != nil {
		return fmt.Errorf("解析签名文件失败: %v", err)
	}

	d.mu.Lock()
	d.signatures = sigData.Signatures
	d.mu.Unlock()

	return nil
}

// DetectFile 检测文件中的漏洞
func (d *VulnerabilityDetector) DetectFile(filePath string) ([]Match, error) {
	content, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("读取文件失败: %v", err)
	}

	matches := make([]Match, 0)
	d.mu.RLock()
	signatures := d.signatures
	d.mu.RUnlock()

	// 使用goroutine并行处理每个签名
	var wg sync.WaitGroup
	matchChan := make(chan Match)
	done := make(chan bool)

	// 启动收集结果的goroutine
	go func() {
		for match := range matchChan {
			matches = append(matches, match)
		}
		done <- true
	}()

	for _, sig := range signatures {
		wg.Add(1)
		go func(signature Signature) {
			defer wg.Done()
			for _, pattern := range signature.CodePatterns {
				re, err := regexp.Compile(pattern)
				if err != nil {
					continue
				}

				// 查找所有匹配
				for _, match := range re.FindAllStringIndex(string(content), -1) {
					matchedCode := string(content[match[0]:match[1]])
					confidence := d.calculateConfidence(matchedCode, pattern)

					if confidence >= d.minConfidence {
						// 计算行号
						lineNumber := 1 + strings.Count(string(content[:match[0]]), "\n")
						matchChan <- Match{
							Signature:   signature,
							LineNumber:  lineNumber,
							MatchedCode: matchedCode,
							Confidence:  confidence,
						}
					}
				}
			}
		}(sig)
	}

	// 等待所有goroutine完成并关闭通道
	go func() {
		wg.Wait()
		close(matchChan)
	}()

	<-done
	return matches, nil
}

// AnalyzeAST 分析AST节点中的漏洞
func (d *VulnerabilityDetector) AnalyzeAST(filePath string) ([]Match, error) {
	fset, node, err := decorator.ParseFile(filePath, nil)
	if err != nil {
		return nil, fmt.Errorf("解析文件失败: %v", err)
	}

	matches := make([]Match, 0)
	d.mu.RLock()
	signatures := d.signatures
	d.mu.RUnlock()

	// 遍历AST
	dst.Inspect(node, func(n dst.Node) bool {
		if call, ok := n.(*dst.CallExpr); ok {
			var funcName string
			switch fun := call.Fun.(type) {
			case *dst.Ident:
				funcName = fun.Name
			case *dst.SelectorExpr:
				if x, ok := fun.X.(*dst.Ident); ok {
					funcName = x.Name + "." + fun.Sel.Name
				}
			default:
				return true
			}

			// 检查是否匹配任何签名
			for _, sig := range signatures {
				for _, pattern := range sig.CodePatterns {
					if matched, _ := regexp.MatchString(pattern, funcName); matched {
						matches = append(matches, Match{
							Signature:   sig,
							LineNumber:  fset.Position(call.Pos()).Line,
							MatchedCode: funcName,
							Confidence:  0.9,
						})
					}
				}
			}
		}
		return true
	})

	return matches, nil
}

// DetectSimilarPatterns 检测相似的漏洞模式
func (d *VulnerabilityDetector) DetectSimilarPatterns(filePath string, threshold float64) ([]Match, error) {
	fset, node, err := decorator.ParseFile(filePath, nil)
	if err != nil {
		return nil, fmt.Errorf("解析文件失败: %v", err)
	}

	matches := make([]Match, 0)
	d.mu.RLock()
	signatures := d.signatures
	d.mu.RUnlock()

	// 遍历AST查找相似模式
	dst.Inspect(node, func(n dst.Node) bool {
		if call, ok := n.(*dst.CallExpr); ok {
			var funcName string
			switch fun := call.Fun.(type) {
			case *dst.Ident:
				funcName = fun.Name
			case *dst.SelectorExpr:
				if x, ok := fun.X.(*dst.Ident); ok {
					funcName = x.Name + "." + fun.Sel.Name
				}
			default:
				return true
			}

			// 检查每个签名
			for _, sig := range signatures {
				for _, pattern := range sig.CodePatterns {
					similarity := d.calculateSimilarity(funcName, pattern)
					if similarity >= threshold {
						matches = append(matches, Match{
							Signature:   sig,
							LineNumber:  fset.Position(call.Pos()).Line,
							MatchedCode: funcName,
							Confidence:  similarity,
						})
					}
				}
			}
		}
		return true
	})

	return matches, nil
}

// calculateConfidence 计算匹配的置信度
func (d *VulnerabilityDetector) calculateConfidence(matchedCode, pattern string) float64 {
	// 基本匹配的置信度为0.7
	confidence := 0.7

	// 根据匹配的完整性增加置信度
	if len(matchedCode) > 10 {
		confidence += 0.1
	}

	// 根据上下文增加置信度
	if strings.Contains(matchedCode, "import") {
		confidence += 0.1
	}

	// 根据模式的特异性增加置信度
	if len(pattern) > 20 {
		confidence += 0.1
	}

	if confidence > 1.0 {
		confidence = 1.0
	}
	return confidence
}

// calculateSimilarity 计算两个字符串的相似度
func (d *VulnerabilityDetector) calculateSimilarity(str1, str2 string) float64 {
	// 使用最长公共子序列(LCS)计算相似度
	m, n := len(str1), len(str2)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}

	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if str1[i-1] == str2[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i][j-1])
			}
		}
	}

	lcsLength := dp[m][n]
	maxLen := max(m, n)
	if maxLen == 0 {
		return 0
	}
	return float64(lcsLength) / float64(maxLen)
}

// max 返回两个整数中的较大值
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
} 