package detectors

import (
    "encoding/json"
    "io/ioutil"
    "os"
    "path/filepath"
    "regexp"
)

// VulnerabilitySignature represents a vulnerability signature
type VulnerabilitySignature struct {
    ID            string   `json:"id"`
    Name          string   `json:"name"`
    Description   string   `json:"description"`
    Severity      string   `json:"severity"`
    CVSS         float64  `json:"cvss"`
    CodePatterns []string `json:"code_patterns"`
    References   []string `json:"references"`
}

// VulnerabilityMatch represents a vulnerability match found in code
type VulnerabilityMatch struct {
    Signature    VulnerabilitySignature
    File         string
    Line         int
    Code         string
    Context      []string
    Confidence   float64
}

// VulnerabilityDetector detects vulnerabilities in code
type VulnerabilityDetector struct {
    signatures []VulnerabilitySignature
    patterns   map[string]*regexp.Regexp
}

// NewVulnerabilityDetector creates a new vulnerability detector
func NewVulnerabilityDetector() *VulnerabilityDetector {
    return &VulnerabilityDetector{
        patterns: make(map[string]*regexp.Regexp),
    }
}

// LoadSignatures loads vulnerability signatures from a JSON file
func (vd *VulnerabilityDetector) LoadSignatures(filename string) error {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return err
    }

    var signatures struct {
        Signatures []VulnerabilitySignature `json:"signatures"`
    }
    if err := json.Unmarshal(data, &signatures); err != nil {
        return err
    }

    vd.signatures = signatures.Signatures

    // Compile regular expressions
    for _, sig := range vd.signatures {
        for _, pattern := range sig.CodePatterns {
            if _, exists := vd.patterns[pattern]; !exists {
                re, err := regexp.Compile(pattern)
                if err != nil {
                    return err
                }
                vd.patterns[pattern] = re
            }
        }
    }

    return nil
}

// DetectFile detects vulnerabilities in a single file
func (vd *VulnerabilityDetector) DetectFile(filename string) ([]VulnerabilityMatch, error) {
    content, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }

    var matches []VulnerabilityMatch
    lines := string(content)

    for _, sig := range vd.signatures {
        for _, pattern := range sig.CodePatterns {
            re := vd.patterns[pattern]
            if re == nil {
                continue
            }

            if re.MatchString(lines) {
                match := VulnerabilityMatch{
                    Signature:  sig,
                    File:      filename,
                    Code:      pattern,
                    Confidence: 0.8,
                }
                matches = append(matches, match)
            }
        }
    }

    return matches, nil
}

// DetectDirectory detects vulnerabilities in all files in a directory
func (vd *VulnerabilityDetector) DetectDirectory(dir string) ([]VulnerabilityMatch, error) {
    var matches []VulnerabilityMatch

    err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        if !info.IsDir() {
            fileMatches, err := vd.DetectFile(path)
            if err != nil {
                return err
            }
            matches = append(matches, fileMatches...)
        }

        return nil
    })

    if err != nil {
        return nil, err
    }

    return matches, nil
} 